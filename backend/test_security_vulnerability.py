import pytest
from flask import Flask
from unittest.mock import patch
import sys
import os

# Add the current directory to sys.path to ensure imports work correctly when running this file directly
sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))

from routes.analysis_routes import analysis_bp

@pytest.fixture
def client():
    app = Flask(__name__)
    # Mocking Config to avoid issues with SECRET_KEY
    app.config['SECRET_KEY'] = 'test-secret-key'
    app.register_blueprint(analysis_bp)
    app.testing = True
    with app.test_client() as client:
        yield client

def test_preliminary_analysis_does_not_leak_exception(client):
    with patch('routes.analysis_routes.analyze_content') as mocked_analyze:
        sensitive_info = "Database password: secret123"
        mocked_analyze.side_effect = Exception(sensitive_info)

        response = client.post('/preliminary', json={'type': 'text', 'content': 'test content'})

        assert response.status_code == 500
        json_data = response.get_json()
        assert json_data['error'] == "Ocorreu um erro interno no servidor"
        assert sensitive_info not in str(json_data)

def test_cross_verification_does_not_leak_exception(client):
    with patch('routes.analysis_routes.cross_verify_content') as mocked_verify:
        sensitive_info = "API Key: key-456"
        mocked_verify.side_effect = Exception(sensitive_info)

        response = client.post('/cross-verification', json={'content': 'test content', 'analysis': {}})

        assert response.status_code == 500
        json_data = response.get_json()
        assert json_data['error'] == "Ocorreu um erro interno no servidor"
        assert sensitive_info not in str(json_data)

def test_context_analysis_does_not_leak_exception(client):
    with patch('routes.analysis_routes.analyze_context') as mocked_context:
        sensitive_info = "File path: /etc/passwd"
        mocked_context.side_effect = Exception(sensitive_info)

        response = client.post('/context', json={'content': 'test content'})

        assert response.status_code == 500
        json_data = response.get_json()
        assert json_data['error'] == "Ocorreu um erro interno no servidor"
        assert sensitive_info not in str(json_data)

def test_final_evaluation_does_not_leak_exception(client):
    with patch('routes.analysis_routes.final_evaluation') as mocked_final:
        sensitive_info = "Traceback: line 42 in db.py"
        mocked_final.side_effect = Exception(sensitive_info)

        response = client.post('/final', json={'user_perception': {}, 'ai_analysis': {}})

        assert response.status_code == 500
        json_data = response.get_json()
        assert json_data['error'] == "Ocorreu um erro interno no servidor"
        assert sensitive_info not in str(json_data)
